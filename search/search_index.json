{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#mono-embeddable-terminal-emulator","title":"Mono: Embeddable Terminal Emulator","text":"<p>New Output Parser</p> <p>See PR #4 on new output parser under development</p> <p>Mono is a terminal emulator that can be embedded in tkinter applications. See examples to see mono in action. The codebase was extracted from the Biscuit project and published as an embeddable widget library.</p> <ul> <li>Supports handling multiple instances of terminals of different shells running simultaneously.</li> <li>Comes as a standalone terminal widget &amp; a tabbed widget as well, for handling different terminal instances.</li> <li>Custom terminals can be made; most shells available on the platform are detected by mono.</li> <li>Themes are fully customizable by the user.</li> </ul> <p></p> examples/tabbed.py<pre><code>import tkinter as tk\nfrom mono import Terminals, get_available_shells, get_shell_from_name\n\nroot = tk.Tk()\nroot.geometry('800x300')\n\nterminals = Terminals(root)\nterminals.add_default_terminal()\nterminals.pack(fill='both', expand=True)\n\n# A menu for opening terminals\nmbtn = tk.Menubutton(root, text=\"Open Terminal\", relief=tk.RAISED)\nmenu = tk.Menu(mbtn)\nfor i in get_available_shells():\n    menu.add_command(label=i, command=lambda i=i: terminals.open_shell(get_shell_from_name(i)))\n\nmbtn.config(menu=menu)\nmbtn.pack()\nroot.mainloop()\n</code></pre> <p><code>Terminals</code> is a container for multiple terminals. It provides a simple interface for managing multiple terminals in a tabbed interface.</p> <p>All the shells detected for the platform can be accessed with <code>get_available_shells()</code>. The <code>get_shell_from_name()</code> function returns a shell object from the name of the shell.</p>"},{"location":"#custom-terminals","title":"Custom Terminals","text":"<p>Following example demonstrates how to create a NodeJS standalone terminal with mono.</p> examples/customshell.py<pre><code># NOTE: Due to the missing additional ANSI handling, NodeJS shell\n# might not work as expected. The issue is being fixed, see pr #4\n\nimport tkinter as tk\nfrom mono import Terminal\n\nclass NodeJS(Terminal):\n    name = \"NodeJS\"\n    shell = \"node\"\n\nroot = tk.Tk()\nterminal = NodeJS(root)\nterminal.start_service()\nterminal.pack(fill='both', expand=True)\n\nroot.mainloop()\n</code></pre>"},{"location":"#custom-theming","title":"Custom Theming","text":"<p>Following example implements a custom light theme for mono terminals</p> examples/customtheme.py<pre><code>import tkinter as tk\nfrom mono import Terminals, Theme\n\nclass Light(Theme):\n    bg = \"#FFFFFF\"\n    fg = \"#000000\"\n    abg = \"#CCCCCC\"\n    afg = \"#000000\"\n    border = \"#DDDDDD\"\n\n    # further overriding the __init__ will give more control over specific widgets:\n    #\n    #    def __init__(self, master=None, **kwargs):\n    #        super().__init__(master, **kwargs)\n    #        self.tabs = (self.bg, 'red')\n\n\nroot = tk.Tk()\nroot.geometry(\"800x300\")\n\nterminals = Terminals(root, theme=Light())\nterminals.pack(fill=\"both\", expand=True)\n\nterminals.open_python()             # open a python console\nterminals.open_another_terminal()   # open another instance of active\n\nroot.mainloop()\n</code></pre> <p>Further...</p> <ul> <li>Shells can be run standalone or in a tabbed interface, see examples/standalone.</li> <li>Custom terminals can be made by subclassing the <code>Terminal</code> class, see examples/customshell.</li> <li>Custom themes can be passed to the <code>Terminal</code>, <code>Terminals</code> classes, see examples/customtheme.</li> <li>High resolution text rendering can be enabled for windows, see examples/highres.</li> </ul> <p>For more examples, see the examples directory.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#terminals","title":"Terminals","text":"<p>               Bases: <code>Frame</code></p> <p>Mono's tabbed terminal manager</p> <p>This widget is a container for multiple terminal instances. It provides methods to create, delete, and manage terminal instances. It also provides methods to run commands in the active terminal and switch between terminals.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Tk</code> <p>Main window.</p> required <code>cwd</code> <code>str</code> <p>Working directory.</p> <code>None</code> <code>theme</code> <code>Theme</code> <p>Custom theme instance.</p> <code>None</code> Source code in <code>mono\\__init__.py</code> <pre><code>class Terminals(tk.Frame):\n    \"\"\"Mono's tabbed terminal manager\n\n    This widget is a container for multiple terminal instances. It provides\n    methods to create, delete, and manage terminal instances. It also provides\n    methods to run commands in the active terminal and switch between terminals.\n\n    Args:\n        master (tk.Tk): Main window.\n        cwd (str): Working directory.\n        theme (Theme): Custom theme instance.\"\"\"\n\n    def __init__(\n        self, master, cwd: str = None, theme: Theme = None, *args, **kwargs\n    ) -&gt; None:\n        super().__init__(master, *args, **kwargs)\n        self.master = master\n        self.base = self\n\n        self.theme = theme or Theme()\n        self.styles = Styles(self, self.theme)\n\n        self.config(bg=self.theme.border)\n        self.grid_rowconfigure(0, weight=1)\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_propagate(False)\n\n        self.cwd = cwd\n\n        self.tabs = Tabs(self)\n        self.tabs.grid(row=0, column=1, padx=(1, 0), sticky=tk.NS)\n\n        self.active_terminals = []\n\n    def add_default_terminal(self, *_) -&gt; Default:\n        \"\"\"Add a default terminal to the list. Create a tab for it.\n\n        Returns:\n            Default: Default terminal instance.\"\"\"\n\n        default_terminal = Default(\n            self, cwd=self.cwd or get_home_directory(), standalone=False\n        )\n        self.add_terminal(default_terminal)\n        return default_terminal\n\n    def add_terminals(self, terminals) -&gt; None:\n        \"\"\"Append multiple terminals to list. Create tabs for them.\n\n        Args:\n            terminals (list): List of Shell types to append.\"\"\"\n\n        for terminal in terminals:\n            self.add_terminal(terminal)\n\n    def add_terminal(self, terminal: Terminal) -&gt; None:\n        \"\"\"Append terminal to list. Create tab for it.\n\n        Args:\n            terminal (Terminal): Shell type to append.\"\"\"\n\n        self.active_terminals.append(terminal)\n        self.tabs.add_tab(terminal)\n\n    def set_cwd(self, cwd: str) -&gt; None:\n        \"\"\"Set current working directory for all terminals.\n\n        Args:\n            cwd (str): Directory path.\"\"\"\n\n        self.cwd = cwd\n\n    def open_shell(self, shell: Terminal) -&gt; None:\n        \"\"\"Creates an instance and opens a shell.\n\n        Args:\n            shell (Terminal): Shell type to open (not instance)\n                use add_terminal() to add existing instance.\"\"\"\n\n        self.add_terminal(\n            shell(self, cwd=self.cwd or get_home_directory(), standalone=False)\n        )\n\n    def open_another_terminal(self, cwd: str = None) -&gt; None:\n        \"\"\"Opens another instance of the active terminal.\n\n        Args:\n            cwd (str): Directory path.\"\"\"\n\n        self.add_terminal(\n            self.active_terminal_type(\n                self, cwd=cwd or self.cwd or get_home_directory(), standalone=False\n            )\n        )\n\n    def delete_all_terminals(self, *_) -&gt; None:\n        \"\"\"Permanently delete all terminal instances.\"\"\"\n\n        for terminal in self.active_terminals:\n            terminal.destroy()\n\n        self.tabs.clear_all_tabs()\n        self.active_terminals.clear()\n        self.refresh()\n\n    def delete_terminal(self, terminal: Terminal) -&gt; None:\n        \"\"\"Permanently delete a terminal instance.\n\n        Args:\n            terminal (Terminal): Terminal instance to delete.\"\"\"\n\n        terminal.destroy()\n        self.active_terminals.remove(terminal)\n\n    def delete_active_terminal(self, *_) -&gt; None:\n        \"\"\"Permanently delete the active terminal.\"\"\"\n\n        try:\n            self.tabs.close_active_tab()\n        except IndexError:\n            pass\n\n    def set_active_terminal(self, terminal: Terminal) -&gt; None:\n        \"\"\"Switch tabs to the terminal.\n\n        Args:\n            terminal (Terminal): Terminal instance to switch to.\"\"\"\n\n        for tab in self.tabs.tabs:\n            if tab.terminal == terminal:\n                self.tabs.set_active_tab(tab)\n\n    def set_active_terminal_by_name(self, name: str) -&gt; None:\n        \"\"\"Switch tabs to the terminal by name.\n\n        Args:\n            name (str): Name of the terminal to switch to.\"\"\"\n\n        for tab in self.tabs.tabs:\n            if tab.terminal.name == name:\n                self.tabs.set_active_tab(tab)\n                break\n\n    def clear_terminal(self, *_) -&gt; None:\n        \"\"\"Clear text in the active terminal.\"\"\"\n\n        if active := self.active_terminal:\n            active.clear()\n\n    def run_command(self, command: str) -&gt; None:\n        \"\"\"Run a command in the active terminal. If there is no active terminal,\n        create a default terminal and run the command.\n\n        Args:\n            command (str): Command to run.\"\"\"\n\n        if not self.active_terminal:\n            default = self.add_default_terminal()\n            default.run_command(command)\n            # this won't work, TODO: implement a queue for commands\n        else:\n            self.active_terminal.run_command(command)\n\n    @staticmethod\n    def run_in_external_console(self, command: str) -&gt; None:\n        \"\"\"Run a command in an external console.\n\n        Args:\n            command (str): Command to run.\"\"\"\n\n        match platform.system():\n            case \"Windows\":\n                subprocess.Popen([\"start\", \"cmd\", \"/K\", command], shell=True)\n            case \"Linux\":\n                subprocess.Popen([\"x-terminal-emulator\", \"-e\", command])\n            case \"Darwin\":\n                subprocess.Popen([\"open\", \"-a\", \"Terminal\", command])\n            case _:\n                print(\"No terminal emulator detected.\")\n\n    def open_pwsh(self, *_):\n        \"\"\"Create a Powershell terminal instance and open it\"\"\"\n\n        self.open_shell(get_shell_from_name(\"Powershell\"))\n\n    def open_cmd(self, *_):\n        \"\"\"Create a Command Prompt terminal instance and open it\"\"\"\n\n        self.open_shell(get_shell_from_name(\"Command Prompt\"))\n\n    def open_bash(self, *_):\n        \"\"\"Create a Bash terminal instance and open it\"\"\"\n\n        self.open_shell(get_shell_from_name(\"Bash\"))\n\n    def open_python(self, *_):\n        \"\"\"Create a Python terminal instance and open it\"\"\"\n\n        self.open_shell(get_shell_from_name(\"Python\"))\n\n    @property\n    def active_terminal_type(self) -&gt; Terminal:\n        \"\"\"Get the type of the active terminal. If there is no active\n        terminal, return Default type.\"\"\"\n\n        if active := self.active_terminal:\n            return type(active)\n\n        return Default\n\n    @property\n    def active_terminal(self) -&gt; Terminal:\n        \"\"\"Get the active terminal instance.\"\"\"\n\n        if not self.tabs.active_tab:\n            return\n\n        return self.tabs.active_tab.terminal\n\n    def refresh(self, *_) -&gt; None:\n        \"\"\"Generates &lt;&lt;Empty&gt;&gt; event that can be bound to hide the terminal\n        if there are no active terminals.\"\"\"\n\n        if not self.active_terminals:\n            self.event_generate(\"&lt;&lt;Empty&gt;&gt;\", when=\"tail\")\n</code></pre>"},{"location":"api-reference/#mono.Terminals.active_terminal","title":"<code>active_terminal: Terminal</code>  <code>property</code>","text":"<p>Get the active terminal instance.</p>"},{"location":"api-reference/#mono.Terminals.active_terminal_type","title":"<code>active_terminal_type: Terminal</code>  <code>property</code>","text":"<p>Get the type of the active terminal. If there is no active terminal, return Default type.</p>"},{"location":"api-reference/#mono.Terminals.add_default_terminal","title":"<code>add_default_terminal(*_)</code>","text":"<p>Add a default terminal to the list. Create a tab for it.</p> <p>Returns:</p> Name Type Description <code>Default</code> <code>Default</code> <p>Default terminal instance.</p> Source code in <code>mono\\__init__.py</code> <pre><code>def add_default_terminal(self, *_) -&gt; Default:\n    \"\"\"Add a default terminal to the list. Create a tab for it.\n\n    Returns:\n        Default: Default terminal instance.\"\"\"\n\n    default_terminal = Default(\n        self, cwd=self.cwd or get_home_directory(), standalone=False\n    )\n    self.add_terminal(default_terminal)\n    return default_terminal\n</code></pre>"},{"location":"api-reference/#mono.Terminals.add_terminal","title":"<code>add_terminal(terminal)</code>","text":"<p>Append terminal to list. Create tab for it.</p> <p>Parameters:</p> Name Type Description Default <code>terminal</code> <code>Terminal</code> <p>Shell type to append.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def add_terminal(self, terminal: Terminal) -&gt; None:\n    \"\"\"Append terminal to list. Create tab for it.\n\n    Args:\n        terminal (Terminal): Shell type to append.\"\"\"\n\n    self.active_terminals.append(terminal)\n    self.tabs.add_tab(terminal)\n</code></pre>"},{"location":"api-reference/#mono.Terminals.add_terminals","title":"<code>add_terminals(terminals)</code>","text":"<p>Append multiple terminals to list. Create tabs for them.</p> <p>Parameters:</p> Name Type Description Default <code>terminals</code> <code>list</code> <p>List of Shell types to append.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def add_terminals(self, terminals) -&gt; None:\n    \"\"\"Append multiple terminals to list. Create tabs for them.\n\n    Args:\n        terminals (list): List of Shell types to append.\"\"\"\n\n    for terminal in terminals:\n        self.add_terminal(terminal)\n</code></pre>"},{"location":"api-reference/#mono.Terminals.clear_terminal","title":"<code>clear_terminal(*_)</code>","text":"<p>Clear text in the active terminal.</p> Source code in <code>mono\\__init__.py</code> <pre><code>def clear_terminal(self, *_) -&gt; None:\n    \"\"\"Clear text in the active terminal.\"\"\"\n\n    if active := self.active_terminal:\n        active.clear()\n</code></pre>"},{"location":"api-reference/#mono.Terminals.delete_active_terminal","title":"<code>delete_active_terminal(*_)</code>","text":"<p>Permanently delete the active terminal.</p> Source code in <code>mono\\__init__.py</code> <pre><code>def delete_active_terminal(self, *_) -&gt; None:\n    \"\"\"Permanently delete the active terminal.\"\"\"\n\n    try:\n        self.tabs.close_active_tab()\n    except IndexError:\n        pass\n</code></pre>"},{"location":"api-reference/#mono.Terminals.delete_all_terminals","title":"<code>delete_all_terminals(*_)</code>","text":"<p>Permanently delete all terminal instances.</p> Source code in <code>mono\\__init__.py</code> <pre><code>def delete_all_terminals(self, *_) -&gt; None:\n    \"\"\"Permanently delete all terminal instances.\"\"\"\n\n    for terminal in self.active_terminals:\n        terminal.destroy()\n\n    self.tabs.clear_all_tabs()\n    self.active_terminals.clear()\n    self.refresh()\n</code></pre>"},{"location":"api-reference/#mono.Terminals.delete_terminal","title":"<code>delete_terminal(terminal)</code>","text":"<p>Permanently delete a terminal instance.</p> <p>Parameters:</p> Name Type Description Default <code>terminal</code> <code>Terminal</code> <p>Terminal instance to delete.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def delete_terminal(self, terminal: Terminal) -&gt; None:\n    \"\"\"Permanently delete a terminal instance.\n\n    Args:\n        terminal (Terminal): Terminal instance to delete.\"\"\"\n\n    terminal.destroy()\n    self.active_terminals.remove(terminal)\n</code></pre>"},{"location":"api-reference/#mono.Terminals.open_another_terminal","title":"<code>open_another_terminal(cwd=None)</code>","text":"<p>Opens another instance of the active terminal.</p> <p>Parameters:</p> Name Type Description Default <code>cwd</code> <code>str</code> <p>Directory path.</p> <code>None</code> Source code in <code>mono\\__init__.py</code> <pre><code>def open_another_terminal(self, cwd: str = None) -&gt; None:\n    \"\"\"Opens another instance of the active terminal.\n\n    Args:\n        cwd (str): Directory path.\"\"\"\n\n    self.add_terminal(\n        self.active_terminal_type(\n            self, cwd=cwd or self.cwd or get_home_directory(), standalone=False\n        )\n    )\n</code></pre>"},{"location":"api-reference/#mono.Terminals.open_bash","title":"<code>open_bash(*_)</code>","text":"<p>Create a Bash terminal instance and open it</p> Source code in <code>mono\\__init__.py</code> <pre><code>def open_bash(self, *_):\n    \"\"\"Create a Bash terminal instance and open it\"\"\"\n\n    self.open_shell(get_shell_from_name(\"Bash\"))\n</code></pre>"},{"location":"api-reference/#mono.Terminals.open_cmd","title":"<code>open_cmd(*_)</code>","text":"<p>Create a Command Prompt terminal instance and open it</p> Source code in <code>mono\\__init__.py</code> <pre><code>def open_cmd(self, *_):\n    \"\"\"Create a Command Prompt terminal instance and open it\"\"\"\n\n    self.open_shell(get_shell_from_name(\"Command Prompt\"))\n</code></pre>"},{"location":"api-reference/#mono.Terminals.open_pwsh","title":"<code>open_pwsh(*_)</code>","text":"<p>Create a Powershell terminal instance and open it</p> Source code in <code>mono\\__init__.py</code> <pre><code>def open_pwsh(self, *_):\n    \"\"\"Create a Powershell terminal instance and open it\"\"\"\n\n    self.open_shell(get_shell_from_name(\"Powershell\"))\n</code></pre>"},{"location":"api-reference/#mono.Terminals.open_python","title":"<code>open_python(*_)</code>","text":"<p>Create a Python terminal instance and open it</p> Source code in <code>mono\\__init__.py</code> <pre><code>def open_python(self, *_):\n    \"\"\"Create a Python terminal instance and open it\"\"\"\n\n    self.open_shell(get_shell_from_name(\"Python\"))\n</code></pre>"},{"location":"api-reference/#mono.Terminals.open_shell","title":"<code>open_shell(shell)</code>","text":"<p>Creates an instance and opens a shell.</p> <p>Parameters:</p> Name Type Description Default <code>shell</code> <code>Terminal</code> <p>Shell type to open (not instance) use add_terminal() to add existing instance.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def open_shell(self, shell: Terminal) -&gt; None:\n    \"\"\"Creates an instance and opens a shell.\n\n    Args:\n        shell (Terminal): Shell type to open (not instance)\n            use add_terminal() to add existing instance.\"\"\"\n\n    self.add_terminal(\n        shell(self, cwd=self.cwd or get_home_directory(), standalone=False)\n    )\n</code></pre>"},{"location":"api-reference/#mono.Terminals.refresh","title":"<code>refresh(*_)</code>","text":"<p>Generates &lt;&gt; event that can be bound to hide the terminal if there are no active terminals. Source code in <code>mono\\__init__.py</code> <pre><code>def refresh(self, *_) -&gt; None:\n    \"\"\"Generates &lt;&lt;Empty&gt;&gt; event that can be bound to hide the terminal\n    if there are no active terminals.\"\"\"\n\n    if not self.active_terminals:\n        self.event_generate(\"&lt;&lt;Empty&gt;&gt;\", when=\"tail\")\n</code></pre>"},{"location":"api-reference/#mono.Terminals.run_command","title":"<code>run_command(command)</code>","text":"<p>Run a command in the active terminal. If there is no active terminal, create a default terminal and run the command.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to run.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def run_command(self, command: str) -&gt; None:\n    \"\"\"Run a command in the active terminal. If there is no active terminal,\n    create a default terminal and run the command.\n\n    Args:\n        command (str): Command to run.\"\"\"\n\n    if not self.active_terminal:\n        default = self.add_default_terminal()\n        default.run_command(command)\n        # this won't work, TODO: implement a queue for commands\n    else:\n        self.active_terminal.run_command(command)\n</code></pre>"},{"location":"api-reference/#mono.Terminals.run_in_external_console","title":"<code>run_in_external_console(command)</code>  <code>staticmethod</code>","text":"<p>Run a command in an external console.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to run.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>@staticmethod\ndef run_in_external_console(self, command: str) -&gt; None:\n    \"\"\"Run a command in an external console.\n\n    Args:\n        command (str): Command to run.\"\"\"\n\n    match platform.system():\n        case \"Windows\":\n            subprocess.Popen([\"start\", \"cmd\", \"/K\", command], shell=True)\n        case \"Linux\":\n            subprocess.Popen([\"x-terminal-emulator\", \"-e\", command])\n        case \"Darwin\":\n            subprocess.Popen([\"open\", \"-a\", \"Terminal\", command])\n        case _:\n            print(\"No terminal emulator detected.\")\n</code></pre>"},{"location":"api-reference/#mono.Terminals.set_active_terminal","title":"<code>set_active_terminal(terminal)</code>","text":"<p>Switch tabs to the terminal.</p> <p>Parameters:</p> Name Type Description Default <code>terminal</code> <code>Terminal</code> <p>Terminal instance to switch to.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def set_active_terminal(self, terminal: Terminal) -&gt; None:\n    \"\"\"Switch tabs to the terminal.\n\n    Args:\n        terminal (Terminal): Terminal instance to switch to.\"\"\"\n\n    for tab in self.tabs.tabs:\n        if tab.terminal == terminal:\n            self.tabs.set_active_tab(tab)\n</code></pre>"},{"location":"api-reference/#mono.Terminals.set_active_terminal_by_name","title":"<code>set_active_terminal_by_name(name)</code>","text":"<p>Switch tabs to the terminal by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the terminal to switch to.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def set_active_terminal_by_name(self, name: str) -&gt; None:\n    \"\"\"Switch tabs to the terminal by name.\n\n    Args:\n        name (str): Name of the terminal to switch to.\"\"\"\n\n    for tab in self.tabs.tabs:\n        if tab.terminal.name == name:\n            self.tabs.set_active_tab(tab)\n            break\n</code></pre>"},{"location":"api-reference/#mono.Terminals.set_cwd","title":"<code>set_cwd(cwd)</code>","text":"<p>Set current working directory for all terminals.</p> <p>Parameters:</p> Name Type Description Default <code>cwd</code> <code>str</code> <p>Directory path.</p> required Source code in <code>mono\\__init__.py</code> <pre><code>def set_cwd(self, cwd: str) -&gt; None:\n    \"\"\"Set current working directory for all terminals.\n\n    Args:\n        cwd (str): Directory path.\"\"\"\n\n    self.cwd = cwd\n</code></pre>"},{"location":"api-reference/#shells","title":"Shells","text":""},{"location":"api-reference/#mono.shells.get_available_shells","title":"<code>get_available_shells()</code>","text":"<p>Return a list of available shells.</p> Source code in <code>mono\\shells\\__init__.py</code> <pre><code>def get_available_shells() -&gt; dict[str, Terminal]:\n    \"\"\"Return a list of available shells.\"\"\"\n\n    return SHELLS\n</code></pre>"},{"location":"api-reference/#mono.shells.get_shell_from_name","title":"<code>get_shell_from_name(name)</code>","text":"<p>Return the shell class from the name.</p> <p>If the shell is not found, return the default shell for the platform.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shell to get.</p> required <p>Returns:</p> Name Type Description <code>Terminal</code> <code>Terminal | Default</code> <p>The shell class.</p> Source code in <code>mono\\shells\\__init__.py</code> <pre><code>def get_shell_from_name(name: str) -&gt; Terminal | Default:\n    \"\"\"Return the shell class from the name.\n\n    If the shell is not found, return the default shell for the platform.\n\n    Args:\n        name (str): The name of the shell to get.\n\n    Returns:\n        Terminal: The shell class.\n    \"\"\"\n\n    return SHELLS.get(name, Default)\n</code></pre>"},{"location":"api-reference/#mono.shells.is_shell_registered","title":"<code>is_shell_registered(name)</code>","text":"<p>Check if a shell is registered.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shell.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the shell is registered, False otherwise.</p> Source code in <code>mono\\shells\\__init__.py</code> <pre><code>def is_shell_registered(name: str) -&gt; bool:\n    \"\"\"Check if a shell is registered.\n\n    Args:\n        name (str): The name of the shell.\n\n    Returns:\n        bool: True if the shell is registered, False otherwise.\n    \"\"\"\n\n    return name in SHELLS\n</code></pre>"},{"location":"api-reference/#mono.shells.register_shell","title":"<code>register_shell(name, shell)</code>","text":"<p>Register a new shell.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shell.</p> required <code>shell</code> <code>Terminal</code> <p>The shell class.</p> required Source code in <code>mono\\shells\\__init__.py</code> <pre><code>def register_shell(name: str, shell: Terminal) -&gt; None:\n    \"\"\"Register a new shell.\n\n    Args:\n        name (str): The name of the shell.\n        shell (Terminal): The shell class.\n    \"\"\"\n\n    SHELLS[name] = shell\n</code></pre>"},{"location":"api-reference/#terminal","title":"Terminal","text":"<p>               Bases: <code>Frame</code></p> <p>Terminal abstract class. All shell types should inherit from this class.</p> The inherited class should implement following attributes <p>name (str): Name of the terminal. shell (str): command / path to shell executable.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Tk</code> <p>Main window.</p> required <code>cwd</code> <code>str</code> <p>Working directory.</p> <code>'.'</code> Source code in <code>mono\\terminal.py</code> <pre><code>class Terminal(ttk.Frame):\n    \"\"\"Terminal abstract class. All shell types should inherit from this class.\n\n    The inherited class should implement following attributes:\n        name (str): Name of the terminal.\n        shell (str): command / path to shell executable.\n\n    Args:\n        master (tk.Tk): Main window.\n        cwd (str): Working directory.\"\"\"\n\n    name: str\n    shell: str\n\n    def __init__(\n        self, master, cwd=\".\", theme: Theme = None, standalone=True, *args, **kwargs\n    ) -&gt; None:\n        super().__init__(master, *args, **kwargs)\n        self.master = master\n        self.standalone = standalone\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_rowconfigure(0, weight=1)\n\n        self.alive = False\n        self.cwd = cwd\n        self.p = None\n\n        if self.standalone:\n            self.base = self\n\n            from .styles import Styles\n            from .theme import Theme\n\n            self.theme = theme or Theme()\n            self.style = Styles(self, self.theme)\n        else:\n            self.base = master.base\n            self.theme = self.base.theme\n\n        self.text = TerminalText(\n            self, relief=tk.FLAT, padx=10, pady=10, font=(\"Consolas\", 11)\n        )\n        self.text.config(\n            bg=self.theme.terminal[0],\n            fg=self.theme.terminal[1],\n            insertbackground=self.theme.terminal[1],\n        )\n        self.text.grid(row=0, column=0, sticky=tk.NSEW)\n        self.text.bind(\"&lt;Return&gt;\", self.enter)\n\n        self.terminal_scrollbar = Scrollbar(self, style=\"MonoScrollbar\")\n        self.terminal_scrollbar.grid(row=0, column=1, sticky=\"NSW\")\n\n        self.text.config(yscrollcommand=self.terminal_scrollbar.set)\n        self.terminal_scrollbar.config(command=self.text.yview, orient=tk.VERTICAL)\n\n        self.text.tag_config(\"prompt\", foreground=\"orange\")\n        self.text.tag_config(\"command\", foreground=\"yellow\")\n\n        self.bind(\"&lt;Destroy&gt;\", self.stop_service)\n\n    def check_shell(self):\n        \"\"\"Check if the shell is available in the system path.\"\"\"\n\n        import shutil\n\n        self.shell = shutil.which(self.shell)\n        return self.shell\n\n    def start_service(self, *_) -&gt; None:\n        \"\"\"Start the terminal service.\"\"\"\n\n        self.alive = True\n        self.last_command = None\n\n        self.p = PTY.spawn([self.shell])\n        Thread(target=self._write_loop, daemon=True).start()\n\n    def stop_service(self, *_) -&gt; None:\n        \"\"\"Stop the terminal service.\"\"\"\n\n        self.alive = False\n\n    def run_command(self, command: str) -&gt; None:\n        \"\"\"Run a command in the terminal.\n        TODO: Implement a queue for running multiple commands.\"\"\"\n\n        self.text.insert(\"end\", command, \"command\")\n        self.enter()\n\n    def enter(self, *_) -&gt; None:\n        \"\"\"Enter key event handler for running commands.\"\"\"\n\n        command = self.text.get(\"input\", \"end\")\n        self.last_command = command\n        self.text.register_history(command)\n        if command.strip():\n            self.text.delete(\"input\", \"end\")\n\n        self.p.write(command + \"\\r\\n\")\n        return \"break\"\n\n    def _write_loop(self) -&gt; None:\n        while self.alive:\n            if buf := self.p.read():\n                p = buf.find(\"\\x1b]0;\")\n\n                if p != -1:\n                    buf = buf[:p]\n                buf = [\n                    strip_ansi_escape_sequences(i)\n                    for i in replace_newline(buf).splitlines()\n                ]\n                self._insert(\"\\n\".join(buf))\n\n    def _insert(self, output: str, tag=\"\") -&gt; None:\n        self.text.insert(tk.END, output, tag)\n        # self.terminal.tag_add(\"prompt\", \"insert linestart\", \"insert\")\n        self.text.see(tk.END)\n        self.text.mark_set(\"input\", \"insert\")\n\n    def _newline(self):\n        self._insert(\"\\n\")\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear the terminal.\"\"\"\n\n        self.text.clear()\n\n    # TODO: Implement a better way to handle key events.\n    def _ctrl_key(self, key: str) -&gt; None:\n        if key == \"c\":\n            self.run_command(\"\\x03\")\n\n    def __str__(self) -&gt; str:\n        return self.name\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.__init__","title":"<code>__init__(master, cwd='.', theme=None, standalone=True, *args, **kwargs)</code>","text":"Source code in <code>mono\\terminal.py</code> <pre><code>def __init__(\n    self, master, cwd=\".\", theme: Theme = None, standalone=True, *args, **kwargs\n) -&gt; None:\n    super().__init__(master, *args, **kwargs)\n    self.master = master\n    self.standalone = standalone\n    self.grid_columnconfigure(0, weight=1)\n    self.grid_rowconfigure(0, weight=1)\n\n    self.alive = False\n    self.cwd = cwd\n    self.p = None\n\n    if self.standalone:\n        self.base = self\n\n        from .styles import Styles\n        from .theme import Theme\n\n        self.theme = theme or Theme()\n        self.style = Styles(self, self.theme)\n    else:\n        self.base = master.base\n        self.theme = self.base.theme\n\n    self.text = TerminalText(\n        self, relief=tk.FLAT, padx=10, pady=10, font=(\"Consolas\", 11)\n    )\n    self.text.config(\n        bg=self.theme.terminal[0],\n        fg=self.theme.terminal[1],\n        insertbackground=self.theme.terminal[1],\n    )\n    self.text.grid(row=0, column=0, sticky=tk.NSEW)\n    self.text.bind(\"&lt;Return&gt;\", self.enter)\n\n    self.terminal_scrollbar = Scrollbar(self, style=\"MonoScrollbar\")\n    self.terminal_scrollbar.grid(row=0, column=1, sticky=\"NSW\")\n\n    self.text.config(yscrollcommand=self.terminal_scrollbar.set)\n    self.terminal_scrollbar.config(command=self.text.yview, orient=tk.VERTICAL)\n\n    self.text.tag_config(\"prompt\", foreground=\"orange\")\n    self.text.tag_config(\"command\", foreground=\"yellow\")\n\n    self.bind(\"&lt;Destroy&gt;\", self.stop_service)\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.check_shell","title":"<code>check_shell()</code>","text":"<p>Check if the shell is available in the system path.</p> Source code in <code>mono\\terminal.py</code> <pre><code>def check_shell(self):\n    \"\"\"Check if the shell is available in the system path.\"\"\"\n\n    import shutil\n\n    self.shell = shutil.which(self.shell)\n    return self.shell\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.clear","title":"<code>clear()</code>","text":"<p>Clear the terminal.</p> Source code in <code>mono\\terminal.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the terminal.\"\"\"\n\n    self.text.clear()\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.enter","title":"<code>enter(*_)</code>","text":"<p>Enter key event handler for running commands.</p> Source code in <code>mono\\terminal.py</code> <pre><code>def enter(self, *_) -&gt; None:\n    \"\"\"Enter key event handler for running commands.\"\"\"\n\n    command = self.text.get(\"input\", \"end\")\n    self.last_command = command\n    self.text.register_history(command)\n    if command.strip():\n        self.text.delete(\"input\", \"end\")\n\n    self.p.write(command + \"\\r\\n\")\n    return \"break\"\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.run_command","title":"<code>run_command(command)</code>","text":"<p>Run a command in the terminal. TODO: Implement a queue for running multiple commands.</p> Source code in <code>mono\\terminal.py</code> <pre><code>def run_command(self, command: str) -&gt; None:\n    \"\"\"Run a command in the terminal.\n    TODO: Implement a queue for running multiple commands.\"\"\"\n\n    self.text.insert(\"end\", command, \"command\")\n    self.enter()\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.start_service","title":"<code>start_service(*_)</code>","text":"<p>Start the terminal service.</p> Source code in <code>mono\\terminal.py</code> <pre><code>def start_service(self, *_) -&gt; None:\n    \"\"\"Start the terminal service.\"\"\"\n\n    self.alive = True\n    self.last_command = None\n\n    self.p = PTY.spawn([self.shell])\n    Thread(target=self._write_loop, daemon=True).start()\n</code></pre>"},{"location":"api-reference/#mono.terminal.Terminal.stop_service","title":"<code>stop_service(*_)</code>","text":"<p>Stop the terminal service.</p> Source code in <code>mono\\terminal.py</code> <pre><code>def stop_service(self, *_) -&gt; None:\n    \"\"\"Stop the terminal service.\"\"\"\n\n    self.alive = False\n</code></pre>"},{"location":"api-reference/#theme","title":"Theme","text":""},{"location":"api-reference/#mono.theme.Theme","title":"<code>Theme</code>","text":"<p>Color theme for the terminal.</p> <p>Attributes:</p> Name Type Description <code>bg</code> <code>str</code> <p>Background color.</p> <code>fg</code> <code>str</code> <p>Foreground color.</p> <code>abg</code> <code>str</code> <p>Active background color.</p> <code>afg</code> <code>str</code> <p>Active foreground color.</p> <code>border</code> <code>str</code> <p>Border color.</p> <code>tabbar</code> <code>str</code> <p>Tab bar background color. This can be modified only after initialization.</p> <code>tab</code> <code>tuple</code> <p>Tab color scheme. This can be modified only after initialization.</p> <code>tabs</code> <code>tuple</code> <p>Tabs color scheme. This can be modified only after initialization.</p> <code>tab_active</code> <code>tuple</code> <p>Active tab color scheme. This can be modified only after initialization.</p> <code>terminal</code> <code>tuple</code> <p>Terminal color scheme. This can be modified only after initialization.</p> <code>scrollbar</code> <code>tuple</code> <p>Scrollbar color scheme. This can be modified only after initialization.</p> Source code in <code>mono\\theme.py</code> <pre><code>class Theme:\n    \"\"\"Color theme for the terminal.\n\n    Attributes:\n        bg (str): Background color.\n        fg (str): Foreground color.\n        abg (str): Active background color.\n        afg (str): Active foreground color.\n        border (str): Border color.\n        tabbar (str): Tab bar background color. This can be modified only after initialization.\n        tab (tuple): Tab color scheme. This can be modified only after initialization.\n        tabs (tuple): Tabs color scheme. This can be modified only after initialization.\n        tab_active (tuple): Active tab color scheme. This can be modified only after initialization.\n        terminal (tuple): Terminal color scheme. This can be modified only after initialization.\n        scrollbar (tuple): Scrollbar color scheme. This can be modified only after initialization.\n    \"\"\"\n\n    bg = \"#181818\"\n    fg = \"#8B949E\"\n    abg = \"#2C2D2D\"\n    afg = \"#CCCCCC\"\n    border = \"#2A2A2A\"\n\n    def __init__(self) -&gt; None:\n        self.tabbar = self.bg\n        self.tab = (self.bg, self.fg, self.abg, self.afg)\n        self.tabs = (self.bg, self.fg)\n        self.tab_active = (self.abg, self.afg)\n        self.terminal = (self.bg, self.fg)\n        self.scrollbar = (self.bg, self.abg)\n</code></pre>"}]}